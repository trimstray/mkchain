#!/usr/bin/env bash

### BEG SCRIPT INFO
#
# Header:
#
#   fname......"sslmerge"
#   cdate......"28.01.2017"
#   mdate......"01.02.2017"
#   version...."1.1-beta"
#   author....."Michał Żurawski <zurawski@bxlab.pl>, <jboowie@bxlab.pl>"
#
# Description:
#
#   See README.md file for more information.
#
# Patches:
#
# License:
#
#   sslmerge, Copyright (C) 2016  Michał Żurawski
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program. If not, see <http://www.gnu.org/licenses/>.
#
### END SCRIPT INFO


PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

umask 022


__init_params=()
__script_params=("$@")

readonly __version="1.1"

readonly __init_name="$(basename "$0")"
readonly __init_directory="$(dirname "$(readlink -f "$0")")"

readonly tdate=$(date +%Y%m%d)

readonly log_file="${__init_name}.${tdate}.log"
readonly log_file_directory="/var/log/${__init_name}"
readonly log_file_full_path="${log_file_directory}/${log_file}"

stdout=""

# Define output file.
output_file=""

# Define array with empty values.
ssl_cert=() ; ssl_keep_attr=()

# Array for storing code for each type of certificate.
readonly ssl_cert_type=(\
                        # intermediate certs
                        "0xA0" \
                        "0xA1" \
                        "0xA2" \
                        "0xA3" \
                        "0xA4" \
                        "0xA5" \
                        "0xA6" \
                        "0xA7" \
                        "0xA8" \
                        "0xA9" \
                        # root ca
                        "0x00" \
                        # server cert
                        "0xZ9" )

openssl_bin=$(which openssl)


# Saving the states of operation to a log file.
function _logger() {

  local _FUNCTION_ID="_logger"
  local _STATE=0

  local type_log_info="$1"
  local info_to_log=$(shift ; echo "$@")

  local log_file_size=0
  local log_file_max_size=10485760

  local convert_type_to_upper=$(echo "$type_log_info" | tr '[:lower:]' '[:upper:]')

  if [ ! -d "$log_file_directory" ] ; then
    mkdir -m 0750 "$log_file_directory" ; fi

  # Checking the log file exceeds the set max size,
  # if the max size is exceeded, the log file will be archived.
  if [ -e "$log_file_full_path" ] ; then
    log_file_size=$(stat -c%s "$log_file_full_path") ; fi

  if [ "$log_file_size" -gt "$log_file_max_size" ] ; then

    local gzip_log_file="${log_file}.${tdate}.tgz"

    tar czfp "$gzip_log_file" -C "$log_file_directory" "$log_file" && \
    mv "$gzip_log_file" "$log_file_directory" && \
    >"$log_file_full_path"

  fi

  # The decision whether an INFO is to be only log to a file
  # or to a file and to standard output.
  if [ "$stdout" == "" ] ; then

    printf "%s  %s:  [%s] %s\n" \
           "$(date +"%d/%m/%y %X")" \
           "$__init_name" \
           "$convert_type_to_upper" \
           "$info_to_log" \
           >>"$log_file_full_path"

  elif [ "$stdout" == "debug" ] ; then

    printf "%s  %s:  [%s] %s\n" \
           "$(date +"%d/%m/%y %X")" \
           "$__init_name" \
           "$convert_type_to_upper" \
           "$info_to_log" \
           | tee -a "$log_file_full_path"

  fi

  # Change permissions to the log file (for security here if the script
  # unexpectedly interrupted by his INFO before).
  chmod o-r "$log_file_full_path"

  # Three states of info:
  #   INFO - normal information log (doesn't perform _exit_ function)
  #   WARN - warning information log (doesn't perform _exit_ function)
  #   STOP - interrupts script execution (does perform _exit_ function)
  #   EXIT - interrupts script execution (doesn't perform _exit_ function)
  if [ "$type_log_info" == "stop" ] ; then _exit_ 255 ; fi

  return $_STATE

}

# Covers the default exit command.
function _exit_() { _STATUS="$1" ; exit "$_STATUS" ; }

# Ensuring they always perform necessary cleanup operations,
# even when something unexpected goes wrong.
function get_trap_SIG() {

  local _FUNCTION_ID="get_trap_SIG"
  local _STATE="$_STATUS"

  if [ -z "$_STATE" ] ; then _STATE=255 ; fi

  _logger exit \
    "${_FUNCTION_ID} exit > signal ${_STATE}"

  return $_STATE

}

# Should be consistent with the contents of the file README.md.
function _help_() {

  local _FUNCTION_ID="_help_"
  local _STATE=0

  printf "%s" "\

  Usage:
    $__init_name [option|long-option]

  Examples:
    $__init_name --help
    $__init_name --cert Root.crt --cert Intermediate1.crt --cert Server.
    $__init_name --debug --cert 01.crt --cert XX.crt --output chain.out

  Options:
    -h, --help                  show this message
    -v, --version               show script version
    -d, --debug                 display information on the screen (debug mode)
    -c, --cert                  stores a certificate (ex. root certificate, intermediate certificate and other)
    -o, --output                saves the result (chain) to file


  $__init_name, Copyright (C) 2016  Michał Żurawski

  This program comes with ABSOLUTELY NO WARRANTY.
  This is free software, and you are welcome to redistribute it
  under certain conditions; for more details please see
  <http://www.gnu.org/licenses/>.

"

  return $_STATE

}

# Function designed to output to the screen in a clear format.
function sprintf() {

  local _FUNCTION_ID="sprintf"
  local _STATE=0

  local _type="$1"
  local _info="$2"

  local _char="" ; local _tcolor=""

  # Determine the type of character and color for each type of output information.
  if [[ $_type == "info" ]] ; then _char="+" ; _tcolor="1;32"
  elif [[ $_type == "warn" ]] ; then _char="-" ; _tcolor="1;33"
  elif [[ $_type == "error" ]] ; then _char="!" ; _tcolor="1;31"
  else _info_char="-" ; _tcolor="0;37"
  fi

  # If you run the tool in verbose mode do not display output using sprintf.
  if [[ "$stdout" != "debug" ]] ; then

    printf '[\e['$_tcolor'm%s\e[m] %s\n' "$_char" "$_info"

  fi

  return $_STATE

}

# Extract information about certificates needed to make a proper chain.
function ssl::info() {

  local _FUNCTION_ID="ssl::info"
  local _STATE=0

  local _ssl_ident_issuer_string="Issuer:"
  local _ssl_ident_subject_string="Subject:"
  local _ssl_regexp_string="CN=.*"

  local _ssl_cert=("${ssl_cert[@]}")

  # Temporary table for storing data in the form key:value.
  local _ssl_keep_attr=()
  local _key=""

  sprintf "warn" "get information from the available certificates"

  for i in "${_ssl_cert[@]}" ; do

    # _key="$(basename "$i")"
    _key="$i"

    sprintf "info" "processing for $_key"

    # Responsible for search 'Issuer' and 'Subject' strings defining the relationship between certificates ;
    # removes all whitespace found in strings => (sed 's/  *//g').
    local _ssl_substr_issuer=$($openssl_bin x509 -text -noout -in "$_key" | \
          grep "$_ssl_ident_issuer_string" | egrep -o "$_ssl_regexp_string" | \
          cut -d "=" -f2 | \
          sed 's/  *//g')

    local _ssl_substr_subject=$($openssl_bin x509 -text -noout -in "$_key" | \
          grep "$_ssl_ident_subject_string" | egrep -o "$_ssl_regexp_string" | \
          cut -d "=" -f2 | \
          sed 's/  *//g')

    _ssl_keep_attr+=("${_key}:${_ssl_substr_issuer}:${_ssl_substr_subject}")

    sprintf "info" "- creating a valid array with 'key':'issuer':'subject'' given certificate"
    sprintf "info" "  - ${_key}:${_ssl_substr_issuer}:${_ssl_substr_subject}"

    _logger info \
      "$_FUNCTION_ID()" \
      "set attr for _ssl_keep_attr=() in 'key':'issuer':'subject' notation, _ssl_keep_attr=() - '${_ssl_keep_attr[-1]}'"

  done

  ssl_keep_attr=("${_ssl_keep_attr[@]}")

  _logger info \
    "$_FUNCTION_ID()" \
    "copy local _ssl_keep_attr=($_ssl_keep_attr) to global ssl_keep_attr=($ssl_keep_attr)"

  return $_STATE

}

# It makes a proper chain of delivered certificates.
function ssl::chain() {

  local _FUNCTION_ID="ssl::chain"
  local _STATE=0

  local _ssl_code_attr_sorted=()

  local _key=""
  local _issuer=""
  local _subject=""

  # Set the default file name if it is not given with option -o|--output.
  if [[ -z $output_file ]] ; then

    output_file="chain.out"

    _logger info \
      "$_FUNCTION_ID()" \
      "set default output filename : '$output_file'"

  fi

  >$output_file

  sprintf "warn" "creating a chain of delivered certificates"

  local _ssl_state=0
  local _ssl_search_last=0
  local _last_issuer=""

  # First search last element from certificates.
  while [[ "$_ssl_state" -eq 0 ]] ; do

    if [[ "$_ssl_search_last" -eq 0 ]] ; then

      sprintf "info" "- searching server certificate"

      _logger info \
        "$_FUNCTION_ID()" \
        "searching server certificate"

      # Extracting data for each element of the array.
      for i in "${ssl_keep_attr[@]}" ; do

        # for _path ; alternative: echo $i | awk -v FS="(:|:)" '{print $1}'
        _path="${i%%:*}"
        # for _subject ; alternative: echo $i | awk -v FS="(:|:)" '{print $3}'
        _subject="${i##*:}"
        # for _issuer ;
        _issuer=$(echo $i | awk -v FS="(:|:)" '{print $2}')

        _logger info \
          "$_FUNCTION_ID()" \
          "extracting items from ${i} => 0:${_path}, 1:${_issuer}, 2:${_subject}"

        if [[ "$_subject" == *"."* ]] ; then

          _last_issuer="$_issuer"
          _last_subject="$_subject"

          _ssl_code_attr_sorted+=("${_path}:${_issuer}:${_subject}")

          sprintf "info" "- found: ${_subject}"

        fi

      done

      _ssl_search_last=1

    fi

    local _ssl_keep_attr_len=${#ssl_keep_attr[@]}
    local _ssl_keep_attr_num=0

    while [[ "$_ssl_keep_attr_len" -eq "${#ssl_keep_attr[@]}" ]] ; do

      sprintf "info" "- search for other certificates"

      _logger info \
        "$_FUNCTION_ID()" \
        "search for other certificates"

      # Extracting data for each element of the array.
      for i in "${ssl_keep_attr[@]}" ; do

        # for _path ; alternative: echo $i | awk -v FS="(:|:)" '{print $1}'
        _path="${i%%:*}"
        # for _subject ; alternative: echo $i | awk -v FS="(:|:)" '{print $3}'
        _subject="${i##*:}"
        # for _issuer ;
        _issuer=$(echo $i | awk -v FS="(:|:)" '{print $2}')

        _logger info \
          "$_FUNCTION_ID()" \
          "extracting items from ${i} => 0:${_path}, 1:${_issuer}, 2:${_subject}"

        for j in "${ssl_keep_attr[@]}" ; do

          # for _path ; alternative: echo $i | awk -v FS="(:|:)" '{print $1}'
          _sub_path="${j%%:*}"
          # for _subject ; alternative: echo $i | awk -v FS="(:|:)" '{print $3}'
          _sub_subject="${j##*:}"
          # for _issuer ;
          _sub_issuer=$(echo $j | awk -v FS="(:|:)" '{print $2}')

          if [[  "$_subject" != "$_last_subject" ]] || [[ "$_issuer" == "$_last_subject" ]] ; then

            sprintf "info" "- found relationship: $_last_subject <==> $_issuer"

            sprintf "info" "  - add certificate for ${_sub_issuer}:${_sub_subject} to chain"

            _ssl_code_attr_sorted+=("${_sub_path}:${_sub_issuer}:${_sub_subject}")

            _logger info \
              "$_FUNCTION_ID()" \
              "found relationship: $_last_subject <==> $_issuer"

          elif [[ "$_subject" != "$_last_subject" ]] || [[ "$_issuer" == "$_sub_subject" ]] ; then

            sprintf "info" "- found relationship: $_sub_subject <==> $_issuer"

            sprintf "info" "  - add certificate for ${_sub_issuer}:${_sub_subject} to chain"

            _ssl_code_attr_sorted+=("${_sub_path}:${_sub_issuer}:${_sub_subject}")

            _logger info \
              "$_FUNCTION_ID()" \
              "found relationship: $_sub_subject <==> $_issuer"    

          fi

          break

        done

      done

      _ssl_keep_attr_len=$((_ssl_keep_attr_len+1))

    done

    _ssl_state=1

  done

  echo "${_ssl_code_attr_sorted[@]}"

  return $_STATE

}

function __main__() {

  local _FUNCTION_ID="__main__"
  local _STATE=0

  _logger init \
    "init '${__init_name}' in ${__init_directory}" && \
  _logger info \
    "__init_params[] = (${__init_params[*]})," \
    "__script_params[] = (${__script_params[*]})"

  cd "$__init_directory"

  local _short_opt="hvdc:o:"
  local _long_opt="help,version,debug,cert:,output:"

  _GETOPT_PARAMS=$(getopt -o "$_short_opt" --long "$_long_opt" \
                  -n "${__init_name}" -- "${__script_params[@]}")

  eval set -- "$_GETOPT_PARAMS"
  while true ; do

    case $1 in

      -h|--help)

        _help_
        shift ; _exit_ 0 ;;

      -v|--version)

        printf "%s, %s\n" "$__init_name" "$__version"
        shift ; _exit_ 0 ;;

      -d|--debug)

        stdout="debug"
        shift ;;

      -c|--cert)

        ssl_cert+=("$2")
        shift 2 ;;

      -o|--output)

        output_file="$2"
        shift 2 ;;

      '') shift ; break ;;
      --) shift ; break ;;
      *) _exit_ 0 ;;

    esac

  done

  if [[ "${#ssl_cert[@]}" -ne "0" ]] ; then

    # We pass without arguments to the function which processes array
    # directly in a function and assigned to the local array.
    ssl::info

    # We call the function responsible for creating the chain. Here when calling
    # anything special but inside the function refers to external array.
    ssl::chain

  fi

  return $_STATE

}

trap get_trap_SIG EXIT

# An array as an argument to a function call __main__,
# is required if we want to operate on arguments of type $1, $2, ...
__main__ "${__script_params[@]}"

_exit_ 0