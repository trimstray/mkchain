#!/usr/bin/env bash

################################################################################
######################## Definitions of user variables #########################
################################################################################

# Define array with empty values.
ssl_delivered_certificates_list=() ; ssl_attr=() ; ssl_attr_sorted=()

# Define the maximum row size in certificate file.
fixed_row_size="64"

# Strings that identifies the certificates.
ssl_beg_cert_id="-----BEGIN CERTIFICATE-----"
ssl_end_cert_id="-----END CERTIFICATE-----"

# Temporary file extension.
fext="tmp"


################################################################################
######################## Definitions of user functions #########################
################################################################################

# ``````````````````````````````````````````````````````````````````````````````
# Function name: sslSetRowSize()
#
# Description:
#   Set maximum row size in cert file.
#
# Usage:
#   sslSetRowSize
#
# Examples:
#   sslSetRowSize
#

function sslSetRowSize() {

  local _FUNCTION_ID="sslSetRowSize"
  local _STATE=0

  local _ssl_delivered_certificates_file="$1"

  # The procedure for parsing a file with a certificate:
  #   - remove the starting string: -----BEGIN CERTIFICATE-----
  #   - remmove the ending string: -----END CERTIFICATE-----
  #   - remove all newline characters
  #   - define the maximum row size in certificate file
  #   - add strings identifying certificate
  #   - prepared written certificate to a temporary file
  grep -v "CERTIFICATE" "${_ssl_delivered_certificates_file}" | \
  tr -d '\n' | \
  tr -d '\r' | \
  sed -e "s/.\{$fixed_row_size\}/&\n/g" | \
  sed -e "1s/^/$ssl_beg_cert_id\n/" | \
  sed -e "\$a$ssl_end_cert_id" \
  > "${_ssl_delivered_certificates_file}.${fext}"

  # Prepared temporary file is written in place of the source file.
  cat "${_ssl_delivered_certificates_file}.${fext}" \
  > "${_ssl_delivered_certificates_file}" && \
  rm -fr "${_ssl_delivered_certificates_file}.${fext}"

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: sslCheck()
#
# Description:
#
# Usage:
#   sslCheck
#
# Examples:
#   sslCheck
#

function sslCheck() {

  local _FUNCTION_ID="sslCheck"
  local _STATE=0

  local _ssl_delivered_certificates_file="$1"
  local _ssl_delivered_certificates_list=()
  local _state="0"

  # Check the correct certificate.
  openssl x509 -text -noout -in "$_ssl_delivered_certificates_file" &>/dev/null && \
  _state="0" || _state="1"

  if [[ "$_state" -eq "0" ]] ; then

    _logger "info" \
      "$_FUNCTION_ID()" \
      "correct certificate: $_ssl_delivered_certificates_file"

    _ssl_delivered_certificates_list+=("$_ssl_delivered_certificates_file")

  else

    _sprintf "stop" "bad certificate (maybe broken): $_ssl_delivered_certificates_file"

    _logger "stop" \
      "$_FUNCTION_ID()" \
      "bad certificate (maybe broken): $_ssl_delivered_certificates_file"

  fi

  ssl_delivered_certificates_list+=("${_ssl_delivered_certificates_list[@]}")

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: sslInfo()
#
# Description:
#   Extract information about certificates needed to make a proper chain.
#
# Usage:
#   sslInfo function_name params
#
# Examples:
#   sslInfo "CheckConn 172.20.20.50 22"
#

function sslInfo() {

  local _FUNCTION_ID="sslInfo"
  local _STATE=0

  local _ssl_ident_issuer_string="Issuer:"
  local _ssl_ident_subject_string="Subject:"
  local _ssl_regexp_string="CN.*=.*"

  local _ssl_delivered_certificates=("${ssl_delivered_certificates_list[@]}")

  local _key_path=""
  local _key_path_name=""
  local _key_issuer=""
  local _key_subject=""

  # Temporary table for storing data in the form path:issuer:subject.
  local _ssl_attr=()

  _logger "info" \
    "$_FUNCTION_ID()" \
    "initialization of variables with initial values"

  for i in "${_ssl_delivered_certificates[@]}" ; do

    _key_path="$i"
    _key_path_name="$(basename "$i")"

    _logger "info" \
      "$_FUNCTION_ID()" \
      "get information from the $_key_path_name"

    # Responsible for search 'Issuer' and 'Subject' strings defining the relationship between certificates ;
    # removes all whitespace found in strings => (sed 's/  *//g').
    _key_issuer=$(openssl x509 -text -noout -in "$_key_path" | \
          grep "$_ssl_ident_issuer_string" | egrep -o "$_ssl_regexp_string" | \
          cut -d "=" -f2 | \
          sed 's/  *//g')

    _key_subject=$(openssl x509 -text -noout -in "$_key_path" | \
          grep "$_ssl_ident_subject_string" | egrep -o "$_ssl_regexp_string" | \
          cut -d "=" -f2 | \
          sed 's/  *//g' | \
          awk -F '[/,]' '{print $1}')

    _logger "info" \
      "$_FUNCTION_ID()" \
      "adding new elements to the array"

    # Assign an element to the array with 'paht:issuer:subject' notation.
    _ssl_attr+=("${_key_path}:${_key_issuer}:${_key_subject}")

    _logger "info" \
      "$_FUNCTION_ID()" \
      "init _ssl_attr=() 'path':'issuer':'subject' notation, _ssl_attr=('${_ssl_attr[-1]}')"

  done

  # Copy the contents of the temporary (local) array to the global array.
  ssl_attr=("${_ssl_attr[@]}")

  _logger "info" \
    "$_FUNCTION_ID()" \
    "copy the contents of local _ssl_attr=() to global ssl_attr=()"

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: sslChain()
#
# Description:
#   It makes a proper chain of delivered certificates.
#
# Usage:
#   sslChain
#
# Examples:
#   sslChain
#

function sslChain() {

  local _FUNCTION_ID="sslChain"
  local _STATE=0

  # In the initial phase is empty, it will be filled with the sorted items
  # forming the correct string.
  local _ssl_attr_sorted=()

  local _key_path=""
  local _key_issuer=""
  local _key_subject=""

  # local _last_issuer=""
  local _last_subject=""

  # Looking for a server certificate (last certificate of the chain).
  sslChainLast

  # Looking for the relationship between certificates.
  sslChainRelation

  # Generate the correct chain.
  sslChainGenerate

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: sslChainLast()
#
# Description:
#   Responsible for establishing the Server/Owner Certificate.
#
# Usage:
#   sslChainLast
#
# Examples:
#   sslChainLast
#

function sslChainLast() {

  local _FUNCTION_ID="sslChainLast"
  local _STATE=0

  local _server_cert_state=""

  # Extracting data for each element of the array.
  for i in "${ssl_attr[@]}" ; do

    # for _key_path ; alternative: echo $i | awk -v FS="(:|:)" '{print $1}'
    _key_path="${i%%:*}"
    # for _key_subject ; alternative: echo $i | awk -v FS="(:|:)" '{print $3}'
    _key_subject="${i##*:}"
    # for _key_issuer ;
    _key_issuer=$(echo "$i" | awk -v FS="(:|:)" '{print $2}')

    _logger "info" \
      "$_FUNCTION_ID()" \
      "extracting items from ${i} => 0:${_key_path}, 1:${_key_issuer}, 2:${_key_subject}"

    # If the box contains CN period (e.g. domain.com)
    if [[ "$_key_subject" == *"."* ]] ; then

      # Very important variables that set the beginning of the chain ;
      # it contain 'Server/Owner Certificate' info.
      # _last_issuer="$_key_issuer"
      _last_subject="$_key_subject"

      printf "Subject:(%s) -> Issuer:(%s)\n" "${_key_subject}" "${_key_issuer}"

      _logger "info" \
        "$_FUNCTION_ID()" \
        "found last relationship: ${_key_subject} <==> ${_key_issuer}"

      _server_cert_state=1

    fi

  done

  if [[ "$_server_cert_state" -ne 1 ]] ; then

    _sprintf "stop" "not found server certificate"

    _logger "stop" \
      "$_FUNCTION_ID()" \
      "not found server certificate"

  fi

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: sslChainRelation()
#
# Description:
#   Set relationship between certificates.
#
# Usage:
#   sslChainRelation
#
# Examples:
#   sslChainRelation
#

function sslChainRelation() {

  local _FUNCTION_ID="sslChainRelation"
  local _STATE=0

  local _ssl_attr_num="0"
  local _ssl_keep_num="0"

  while [[ "$_ssl_attr_num" -lt "${#ssl_attr[@]}" ]] ; do

    # Extracting data for each element of the array.
    for i in "${ssl_attr[@]}" ; do

    if [[ "$_ssl_keep_num" -lt "${#ssl_attr[@]}" ]] ; then

      # for _key_path ; alternative: echo $i | awk -v FS="(:|:)" '{print $1}'
      _key_path="${i%%:*}"
      # for _key_subject ; alternative: echo $i | awk -v FS="(:|:)" '{print $3}'
      _key_subject="${i##*:}"
      # for _key_issuer ;
      _key_issuer=$(echo "$i" | awk -v FS="(:|:)" '{print $2}')

      _logger "info" \
        "$_FUNCTION_ID()" \
        "extracting items from ${i} => 0:${_key_path}, 1:${_key_issuer}, 2:${_key_subject}"

      # Compares the current field 'Subject' certificate processed
      # on the last field 'Subject' of the previous certificate.
      if [[ "$_key_subject" == "$_last_subject" ]] ; then

        # Assign an element to the array with 'paht:issuer:subject' notation.
        _ssl_attr_sorted+=("${_key_path}:${_key_issuer}:${_last_subject}")

        printf "Subject:(%s) -> Issuer:(%s)\n" "${_last_subject}" "${_key_issuer}"

        _logger "info" \
          "$_FUNCTION_ID()" \
          "found relationship: $_last_subject <==> $_key_issuer"

        _last_subject="$_key_issuer"

        _ssl_keep_num=$((_ssl_keep_num+1))

      fi

    fi

    done

    _ssl_attr_num=$((_ssl_attr_num+1))

  done

  # Copy the sorted contents of the temporary (local) array to the global array.
  ssl_attr_sorted=("${_ssl_attr_sorted[@]}")

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: sslChainGenerate()
#
# Description:
#   It generate a proper chain of delivered certificates.
#
# Usage:
#   sslChainGenerate
#
# Examples:
#   sslChainGenerate
#

function sslChainGenerate() {

  local _FUNCTION_ID="sslChainGenerate"
  local _STATE=0

  # The mechanism involved in the location of sorted items.
  for i in "${ssl_attr_sorted[@]}" ; do

    _absolute_path="${i%%:*}"
    _path="$(basename "$_absolute_path")"

    _logger "info" \
      "$_FUNCTION_ID()" \
      "add $_path"

    # alternative: (cat "$_absolute_path" ; echo) >> "$_fd"
    cat "$_absolute_path" >> "$_fd"

  done

  return $_STATE

}
