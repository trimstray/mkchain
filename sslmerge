#!/usr/bin/env bash

### BEG SCRIPT INFO
#
# Header:
#
#         fname : "sslmerge"
#         cdate : "28.01.2017"
#         mdate : "18.02.2017"
#       version : "v1.1b"
#        author : "Michał Żurawski <michal.zurawski@bxlab.pl>"
#          site : "https://jb-public.github.io/sslmerge"
#      tab_size : "2"
#     soft_tabs : "YES"
#
# Description:
#
#   See README.md file for more information.
#
# Patches:
#
# License:
#
#   sslmerge, Copyright (C) 2017  Michał Żurawski
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program. If not, see <http://www.gnu.org/licenses/>.
#
### END SCRIPT INFO


################################################################################
################## The configuration parameters of the script ##################
################################################################################

# Bash 'Strict Mode'.
set -o errexit
set -o pipefail
# set -o nounset
# set -o xtrace

# Internal field separator (more flexible).
IFS_ORIG="$IFS"
IFS=$'\n\t'

# PATH environment variable setup.
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

# Setting permissions in the script environment:
#   0022 - less restrictive settings (default value)
#   0027 - for better security
#   0077 - only for root access (more restrictive)
umask 0027


################################################################################
############################### Global variables ###############################
################################################################################

# The tables that store call parameters.
__init_params=()
__script_params=("$@")

readonly __version="v1.1b"

# Store the name of the script and directory call.
readonly __init_name="$(basename "$0")"
readonly __init_directory="$(dirname "$(readlink -f "$0")")"

readonly __date=$(date +%Y%m%d)

# Variables related to the log file. Divided into three parts due
# to the better possibility of manipulation for the user.
readonly __logfile="${__init_name}.${__date}.log"
readonly __logdir="/var/log/${__init_name}"
readonly __logpath="${__logdir}/${__logfile}"

# The definition of the variable responsible for displaying information
# on the screen. By default, stores the empty value.
#   ""    - default messages (without debug mode)
#   debug - show debug messages
stdout=""

# The variable that holds the main (external) configuration file.
# Initially accepts an empty value which is changed when calling
# the script with the parameter -c|--config "value".
main_config=""

# Define output file and default filename.
_fd=""
_fd_default="chain.out"

# Define array with empty values.
ssl_delivered_certificates=() ; ssl_attr=() ; ssl_attr_sorted=()


################################################################################
############################ Used external commands ############################
################################################################################

# We place here used commands at script runtime.
readonly __commands=(tar gzip stat date openssl)

# Stores the names of the missing commands.
missing_hash=()

missing_counter=0

if [[ -n "${missing_hash[@]}" ]] ; then

  for i in "${__commands[@]}" ; do

    # If the command was not found put it in the array.
    if ! hash "$i" >/dev/null 2>&1 ; then

      missing_hash+=("$i")

      ((missing_counter++))

    fi

  done ; unset i

  if [[ "$missing_counter" -gt "0" ]] ; then

    printf "Commands not found in PATH: %s\n" "${missing_hash[@]}" >&2
    exit 1

  fi

fi

# If you intend to specify the full path to the command we do it like:
#   readonly _tar="/bin/tar"


################################################################################
####################### Definitions of global functions ########################
################################################################################

# ``````````````````````````````````````````````````````````````````````````````
# Function name: _logger()
#
# Description:
#   Saving the states of operation to a log file.
#
# Usage:
#   _logger type "()" "message"
#
# Examples:
#   _logger info "()" "load config file properly"
#   _logger stop "()" "not connected"
#
function _logger() {

  local _FUNCTION_ID="_logger"
  local _STATE=0

  local type_log_info="$1"
  local info_to_log=$(shift ; echo "$@")

  local logfile_size=0
  local logfile_max_size=10485760

  local convert_type_to_upper=$(echo "$type_log_info" | \
                              tr '[:lower:]' '[:upper:]')

  if [ ! -d "$__logdir" ] ; then
    mkdir -m 0750 "$__logdir" ; fi

  # Checking the log file exceeds the set max size,
  # if the max size is exceeded, the log file will be archived.
  if [ -e "$__logpath" ] ; then
    logfile_size=$(stat -c%s "$__logpath") ; fi

  if [ "$logfile_size" -gt "$logfile_max_size" ] ; then

    local gzip_logfile="${__logfile}.${__date}.tgz"

    tar czfp "$gzip_logfile" -C "$__logdir" "$__logfile" && \
    mv "$gzip_logfile" "$__logdir" && \
    >"$__logpath"

  fi

  # The decision whether an INFO is to be only log to a file
  # or to a file and to standard output.
  if [ "$stdout" == "" ] ; then

    printf "%s  %s:  [%s] %s\n" \
           "$(date +"%d/%m/%y %X")" \
           "$__init_name" \
           "$convert_type_to_upper" \
           "$info_to_log" \
           >>"$__logpath"

  elif [ "$stdout" == "debug" ] ; then

    printf "%s  %s:  [%s] %s\n" \
           "$(date +"%d/%m/%y %X")" \
           "$__init_name" \
           "$convert_type_to_upper" \
           "$info_to_log" \
           | tee -a "$__logpath"

  fi

  # Change permissions to the log file (for security here if the script
  # unexpectedly interrupted by his INFO before).
  chmod o-r "$__logpath"

  # _logger() lets you exit the program with the parameter 'stop'
  # and '255' exit code.
  #
  # Three states of info:
  #   INFO - normal information log (doesn't perform _exit_ function)
  #   WARN - warning information log (doesn't perform _exit_ function)
  #   STOP - interrupts script execution (does perform _exit_ function)
  #   EXIT - interrupts script execution (doesn't perform _exit_ function)
  if [ "$type_log_info" == "stop" ] ; then _exit_ 255 ; fi

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: _exit_()
#
# Description:
#   Covers the default exit command.
#
# Usage:
#   _exit_ value
#
# Examples:
#   _exit_ 0
#
function _exit_() { _STATUS="$1" ; exit "$_STATUS" ; }


# ``````````````````````````````````````````````````````````````````````````````
# Function name: get_trap_SIG()
#
# Description:
#   Ensuring they always perform necessary cleanup operations,
#   even when something unexpected goes wrong.
#
# Usage:
#   trap get_trap_SIG SIGNAL
#
# Examples:
#   trap get_trap_SIG EXIT
#
function get_trap_SIG() {

  local _FUNCTION_ID="get_trap_SIG"
  local _STATE="$_STATUS"

  if [ -z "$_STATE" ] ; then _STATE=255 ; fi

  _logger exit \
    "${_FUNCTION_ID} exit > signal ${_STATE}"

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: _sprintf()
#
# Description:
#   Function designed to output to the screen in a clear format.
#
# Usage:
#   _sprintf "type" "message"
#
# Examples:
#   _sprintf "head" "correct certificate: $_ssl_delivered_certificates_file"
#
function _sprintf() {

  local _FUNCTION_ID="_sprintf"
  local _STATE=0

  local _type="$1"
  local _info="$2"

  local _char="" ; local _tcolor=""

  # Determine the type of character and color for each type
  # of output information.
  if [[ $_type == "info" ]] ; then _char="-" ; _tcolor="0;33"
  elif [[ $_type == "head" ]] ; then _char="+" ; _tcolor="1;32"
  elif [[ $_type == "stop" ]] ; then _char="!" ; _tcolor="1;31"
  else _char="-" ; _tcolor="0;37"
  fi

  # If you run the tool in verbose mode do not display output using _sprintf.
  if [[ "$stdout" != "debug" ]] ; then

    if [[ "$_type" == "spin" ]] && [[ ! -z "$_info" ]] ; then

      # Process id of the previous running command.
      local _pid="$_info"

      local _sc='-\|/'

      # Verify that the process is still running.
      local n=0
      while kill -0 $_pid 2>/dev/null ; do

        n=$(( ( n + 1 ) % 4 ))
        printf "\r[${_sc:$n:1}]"
        sleep 0.1

      done

      # If the end, we clean.
      printf "\r"

    else

      # Normal execution if:
      # - spinner has not been called
      # - spinner completed
      printf '[\e['$_tcolor'm%s\e[m] %s\n' "$_char" "$_info"

    fi

  fi

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: _config()
#
# Description:
#   Responsible for loading the configuration file, $main_config variable
#   parameter is defined in the script call.
#
# Usage:
#   _config "path_to_config_file"
#
# Examples:
#   _config "$main_config"
#
function _config() {

  local _FUNCTION_ID="_config"
  local _STATE=0

  local _config="$1"

  if [ -e "$_config" ] ; then

    _sprintf "head" "load $_config properly"

    # If the file exists is loaded.
    . "$_config" && \
    _logger info \
      "$_FUNCTION_ID()" \
      "load $_config properly"

  elif [ -z "$_config" ] ; then

    _sprintf "stop" "load config error (use -c|--config option)"

    _logger stop \
      "$_FUNCTION_ID()" \
      "load config error (use -c|--config option)"

  else

    _sprintf "stop" "load $_config error (does not exist?)"

    _logger stop \
      "$_FUNCTION_ID()" \
      "load $_config error (does not exist?)"

  fi

  return $_STATE

}


################################################################################
################# Definitions of user variables and functions ##################
################################################################################

# ``````````````````````````````````````````````````````````````````````````````
# Function name: _before_init()
#
# Description:
#   INFOs performed before calling the __main__ function, eg.
#   attaching files, cleaning logs (if you need a function that will deal
#   with it, put it here).
#
# Usage:
#   _before_init
#
# Examples:
#   _before_init
#
function _before_init() {

  local _FUNCTION_ID="_before_init"
  local _STATE=0

  cd $__init_directory

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: _after_init()
#
# Description:
#   INFOs performed after calling the __main__ function, eg.
#   cleaning logs (if you need a function that will deal with it,
#   put it here).
#
# Usage:
#   _after_init
#
# Examples:
#   _after_init
#
function _after_init() {

  local _FUNCTION_ID="_after_init"
  local _STATE=0

  cd $__init_directory

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: _help_()
#
# Description:
#   Help message. Should be consistent with the contents of the file README.md.
#
# Usage:
#   _help_
#
# Examples:
#   _help_
#
function _help_() {

  local _FUNCTION_ID="_help_"
  local _STATE=0

  printf "%s" "\

  Usage:
    $__init_name [option|long-option]

  Examples:
    $__init_name --help
    $__init_name --cert Root.crt --cert Intermediate1.crt --cert Server.crt
    $__init_name --debug --cert 01.crt --cert XX.crt --output nginx_bundle.crt
    $__init_name --cert /tmp/certs/ --output nginx_bundle.crt

  Options:
    -h, --help                  show this message
    -v, --version               show script version
    -d, --debug                 display information on the screen (debug mode)
    -a, --attach                attach an external file to the script
    -c, --cert                  stores a cert single file or directory with certs (with last '/')
    -o, --output                saves the result (chain) to file


  $__init_name, Copyright (C) 2016  Michał Żurawski

  This program comes with ABSOLUTELY NO WARRANTY.
  This is free software, and you are welcome to redistribute it
  under certain conditions; for more details please see
  <http://www.gnu.org/licenses/>.

"

  return $_STATE

}

function ssl::check() {

  local _FUNCTION_ID="ssl::check"
  local _STATE=0

  local _ssl_delivered_certificates_file="$1"
  local _ssl_delivered_certificates_list=()
  local _state="0"

  # Check the correct certificate.
  openssl x509 -text -noout -in "$_ssl_delivered_certificates_file" &>/dev/null && \
  _state="0" || _state="1"

  if [[ "$_state" -eq "0" ]] ; then

    _sprintf "head" "correct certificate: $_ssl_delivered_certificates_file"

    _logger info \
      "$_FUNCTION_ID()" \
      "correct certificate: $_ssl_delivered_certificates_file"

    _ssl_delivered_certificates_list+=("$_ssl_delivered_certificates_file")

  else

    _sprintf "stop" "bad certificate (maybe broken): $_ssl_delivered_certificates_file"

    # We stop the script using the passed argument 'stop' to _logger() function.
    _logger stop \
      "$_FUNCTION_ID()" \
      "bad certificate (maybe broken): $_ssl_delivered_certificates_file"

  fi

  ssl_delivered_certificates_list+=("${_ssl_delivered_certificates_list[@]}")

  return $_STATE

}

# Extract information about certificates needed to make a proper chain.
function ssl::info() {

  local _FUNCTION_ID="ssl::info"
  local _STATE=0

  local _ssl_ident_issuer_string="Issuer:"
  local _ssl_ident_subject_string="Subject:"
  local _ssl_regexp_string="CN=.*"

  local _ssl_delivered_certificates=("${ssl_delivered_certificates_list[@]}")

  local _key_path=""
  local _key_path_name=""
  local _key_issuer=""
  local _key_subject=""

  # Temporary table for storing data in the form path:issuer:subject.
  local _ssl_attr=()

  _logger info \
    "$_FUNCTION_ID()" \
    "initialization of variables with initial values"

  for i in "${_ssl_delivered_certificates[@]}" ; do

    _key_path="$i"
    _key_path_name="$(basename "$i")"

    _sprintf "head" "get information from the $_key_path_name" && \
    _logger info \
      "$_FUNCTION_ID()" \
      "get information from the $_key_path_name"

    # Responsible for search 'Issuer' and 'Subject' strings defining the relationship between certificates ;
    # removes all whitespace found in strings => (sed 's/  *//g').
    _key_issuer=$(openssl x509 -text -noout -in "$_key_path" | \
          grep "$_ssl_ident_issuer_string" | egrep -o "$_ssl_regexp_string" | \
          cut -d "=" -f2 | \
          sed 's/  *//g')

    _key_subject=$(openssl x509 -text -noout -in "$_key_path" | \
          grep "$_ssl_ident_subject_string" | egrep -o "$_ssl_regexp_string" | \
          cut -d "=" -f2 | \
          sed 's/  *//g' | \
          awk -F '/' '{print $1}')

    _logger info \
      "$_FUNCTION_ID()" \
      "adding new elements to the array"

    # Assign an element to the array with 'paht:issuer:subject' notation.
    _ssl_attr+=("${_key_path}:${_key_issuer}:${_key_subject}")

    _sprintf "info" " path: ${_key_path_name}"
    _sprintf "info" " issuer: ${_key_issuer}"
    _sprintf "info" " subject: ${_key_subject}"

    _logger info \
      "$_FUNCTION_ID()" \
      "init _ssl_attr=() 'path':'issuer':'subject' notation, _ssl_attr=('${_ssl_attr[-1]}')"

  done

  # Copy the contents of the temporary (local) array to the global array.
  ssl_attr=("${_ssl_attr[@]}")

  _logger info \
    "$_FUNCTION_ID()" \
    "copy the contents of local _ssl_attr=() to global ssl_attr=()"

  return $_STATE

}

# It makes a proper chain of delivered certificates.
function ssl::chain() {

  local _FUNCTION_ID="ssl::chain"
  local _STATE=0

  # In the initial phase is empty, it will be filled with the sorted items
  # forming the correct string.
  local _ssl_attr_sorted=()

  local _key_path=""
  local _key_issuer=""
  local _key_subject=""

  local _last_issuer=""
  local _last_subject=""

  _sprintf "head" "creating a chain of delivered certificates"

  # Looking for a server certificate (last certificate of the chain).
  ssl::chain::last

  # Looking for the relationship between certificates.
  ssl::chain::rel

  # Generate the correct chain.
  ssl::chain::gen

  return $_STATE

}

# Responsible for establishing the Server/Owner Certificate.
function ssl::chain::last() {

  local _FUNCTION_ID="ssl::chain::last"
  local _STATE=0

  # Extracting data for each element of the array.
  for i in "${ssl_attr[@]}" ; do

    # for _key_path ; alternative: echo $i | awk -v FS="(:|:)" '{print $1}'
    _key_path="${i%%:*}"
    # for _key_subject ; alternative: echo $i | awk -v FS="(:|:)" '{print $3}'
    _key_subject="${i##*:}"
    # for _key_issuer ;
    _key_issuer=$(echo "$i" | awk -v FS="(:|:)" '{print $2}')

    _logger info \
      "$_FUNCTION_ID()" \
      "extracting items from ${i} => 0:${_key_path}, 1:${_key_issuer}, 2:${_key_subject}"

    # If the box contains CN period (eg. domain.com)
    if [[ "$_key_subject" == *"."* ]] ; then

      # Very important variables that set the beginning of the chain ;
      # it contain 'Server/Owner Certificate' info.
      _last_issuer="$_key_issuer"
      _last_subject="$_key_subject"

      _logger info \
        "$_FUNCTION_ID()" \
        "found server certificate: ${_key_subject}"

      _sprintf "info" " found server certificate: ${_key_subject}"
      # _sprintf "info" " last relationship: ${_key_subject} <==> ${_key_issuer}"

      _logger info \
        "$_FUNCTION_ID()" \
        "found last relationship: ${_key_subject} <==> ${_key_issuer}"

    fi

  done

  return $_STATE

}

# Set relationship between certificates.
function ssl::chain::rel() {

  local _FUNCTION_ID="ssl::chain::rel"
  local _STATE=0

  local _ssl_attr_num="0"
  local _ssl_keep_num="0"

  while [[ "$_ssl_attr_num" -lt "${#ssl_attr[@]}" ]] ; do

    # Extracting data for each element of the array.
    for i in "${ssl_attr[@]}" ; do

    if [[ "$_ssl_keep_num" -lt "${#ssl_attr[@]}" ]] ; then

      # for _key_path ; alternative: echo $i | awk -v FS="(:|:)" '{print $1}'
      _key_path="${i%%:*}"
      # for _key_subject ; alternative: echo $i | awk -v FS="(:|:)" '{print $3}'
      _key_subject="${i##*:}"
      # for _key_issuer ;
      _key_issuer=$(echo "$i" | awk -v FS="(:|:)" '{print $2}')

      _logger info \
        "$_FUNCTION_ID()" \
        "extracting items from ${i} => 0:${_key_path}, 1:${_key_issuer}, 2:${_key_subject}"

      # Compares the current field 'Subject' certificate processed
      # on the last field 'Subject' of the previous certificate.
      if [[ "$_key_subject" == "$_last_subject" ]] ; then

        _sprintf "info" " found relationship: $_key_subject <==> $_key_issuer"

        _sprintf "info" " cert file: $_key_path"

        # Assign an element to the array with 'paht:issuer:subject' notation.
        _ssl_attr_sorted+=("${_key_path}:${_key_issuer}:${_last_subject}")

        _logger info \
          "$_FUNCTION_ID()" \
          "found relationship: $_last_subject <==> $_key_issuer"

        _last_subject="$_key_issuer"

        _ssl_keep_num=$((_ssl_keep_num+1))

      fi

    fi

    done

    _ssl_attr_num=$((_ssl_attr_num+1))

  done

  # Copy the sorted contents of the temporary (local) array to the global array.
  ssl_attr_sorted=("${_ssl_attr_sorted[@]}")

  return $_STATE

}

# It generate a proper chain of delivered certificates.
function ssl::chain::gen() {

  local _FUNCTION_ID="ssl::chain::gen"
  local _STATE=0

  _sprintf "head" "generating $_fd file with the correct chain"

  # The mechanism involved in the location of sorted items.
  for i in "${ssl_attr_sorted[@]}" ; do

    _absolute_path="${i%%:*}"
    _path="$(basename "$_absolute_path")"

    _logger info \
      "$_FUNCTION_ID()" \
      "add $_path"

    _sprintf "info" " add: $_path"

    (cat "$_absolute_path" ; echo) >> "$_fd"

  done

  return $_STATE

}

function __main__() {

  local _FUNCTION_ID="__main__"
  local _STATE=0

  _logger init \
    "init '${__init_name}' in ${__init_directory}" && \
  _logger info \
    "__init_params[] = (${__init_params[*]})," \
    "__script_params[] = (${__script_params[*]})"

  cd "$__init_directory"

  local _short_opt="hvdac:o:"
  local _long_opt="help,version,debug,attach,cert:,output:"

  _GETOPT_PARAMS=$(getopt -o "$_short_opt" --long "$_long_opt" \
                  -n "${__init_name}" -- "${__script_params[@]}")

  eval set -- "$_GETOPT_PARAMS"
  while true ; do

    case $1 in

      -h|--help)

        _help_
        shift ; _exit_ 0 ;;

      -v|--version)

        printf "%s, %s\n" "$__init_name" "$__version"
        shift ; _exit_ 0 ;;

      -d|--debug)

        stdout="debug"
        shift ;;

      -a|--attach)

        main_config="$2"
        shift 2 ;;

      -c|--cert)

        ssl_delivered_certificates+=("$2")
        shift 2 ;;

      -o|--output)

        _fd="$2"
        shift 2 ;;

      '') shift ; break ;;
      --) shift ; break ;;
      *) _exit_ 0 ;;

    esac

  done

  ################################# USER SPACE #################################
  # ````````````````````````````````````````````````````````````````````````````
  # Put here all your variable declarations, function calls
  # and all the other code blocks.

  # Without the specified file configuration script fails to execute.
  # uncomment if you are using the main configuration file.
  # _config "$main_config"

  # Check whether a file exists.
  if [[ -f "$_fd" ]] ; then

    # Set the default file name if it is not given with option -o|--output.
    if [[ -z "$_fd" ]] ; then

    _fd="$_fd_default"

      _logger info \
        "$_FUNCTION_ID()" \
        "set output filename to (default filename)'$_fd'"

    else

      _logger info \
        "$_FUNCTION_ID()" \
        "set output filename to '$_fd'"

    fi

    _logger info \
      "$_FUNCTION_ID()" \
      "clear the contents of the '$_fd' properly"
      
    >$_fd

  else

    # If the file path is incorrect.
    _sprintf "stop" "$_fd file path is incorrect (maybe directory?)"

    _logger stop \
      "$_FUNCTION_ID()" \
      "$_fd file path is incorrect (maybe directory?)"

  fi

  if [[ "${#ssl_delivered_certificates[@]}" -ne "0" ]] ; then

    local ssl_delivered_certificates_list=()

    # For better control of the log file (do not use _sprintf).
    for i in "${ssl_delivered_certificates[@]}" ; do

      if [[ -f "$i" ]] ; then

        ssl::check "$i"

        _logger info \
          "$_FUNCTION_ID()" \
          "script param '$i' is a file"

      elif [[ -d "$i" ]] ; then

        _logger info \
          "$_FUNCTION_ID()" \
          "script param '$i' is a directory"

        for j in $(ls -p "$i" | grep -v /) ; do

          local _ssl_path_plus_name="${i}${j}"

          ssl::check "$_ssl_path_plus_name"

          _logger info \
            "$_FUNCTION_ID()" \
            "script param '$i' is a file"

        done

      else

        # If the file/directory is not valid.
        _sprintf "stop" "incorrect file/directory: $i"

        _logger stop \
          "$_FUNCTION_ID()" \
          "incorrect file/directory: $i"

      fi

    done

    # We pass without arguments to the function which processes array
    # directly in a function and assigned to the local array.
    ssl::info

    # We call the function responsible for creating the chain. Here when calling
    # anything special but inside the function refers to external array.
    ssl::chain

  fi

  # ````````````````````````````````````````````````````````````````````````````

  return $_STATE

}

trap get_trap_SIG EXIT

# An array as an argument to a function call __main__,
# is required if we want to operate on arguments of type $1, $2, ...
__main__ "${__script_params[@]}"

_exit_ 0
