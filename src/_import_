################################################################################
######################## Definitions of user variables #########################
################################################################################

# Define output file handler.
_fd=""

# Define array with empty values.
ssl_delivered_certificates_list=() ; ssl_attr=() ; ssl_attr_sorted=()

# Define the maximum row size in certificate file.
fixed_row_size="64"

# Strings that identifies the certificates.
ssl_beg_cert_id="-----BEGIN CERTIFICATE-----"
ssl_end_cert_id="-----END CERTIFICATE-----"

# Temporary file extension.
fext="tmp"


################################################################################
######################## Definitions of user functions #########################
################################################################################

# Set maximum row size in cert file.
function sslSetRowSize() {

  local _FUNCTION_ID="sslSetRowSize"
  local _STATE=0

  local _ssl_delivered_certificates_file="$1"

  # The procedure for parsing a file with a certificate:
  #   - remove the starting string: -----BEGIN CERTIFICATE-----
  #   - remmove the ending string: -----END CERTIFICATE-----
  #   - remove all newline characters
  #   - define the maximum row size in certificate file
  #   - add strings identifying certificate
  #   - prepared written certificate to a temporary file
  grep -v "CERTIFICATE" "${_ssl_delivered_certificates_file}" | \
  tr -d '\n' | \
  sed -e "s/.\{$fixed_row_size\}/&\n/g" | \
  sed -e "1s/^/$ssl_beg_cert_id\n/" | \
  sed -e "\$a$ssl_end_cert_id" \
  > "${_ssl_delivered_certificates_file}.${fext}"

  # Prepared temporary file is written in place of the source file.
  cat "${_ssl_delivered_certificates_file}.${fext}" \
  > "${_ssl_delivered_certificates_file}" && \
  rm -fr "${_ssl_delivered_certificates_file}.${fext}"

  return $_STATE

}

function sslCheck() {

  local _FUNCTION_ID="sslCheck"
  local _STATE=0

  local _ssl_delivered_certificates_file="$1"
  local _ssl_delivered_certificates_list=()
  local _state="0"

  # Check the correct certificate.
  openssl x509 -text -noout -in "$_ssl_delivered_certificates_file" &>/dev/null && \
  _state="0" || _state="1"

  if [[ "$_state" -eq "0" ]] ; then

    _sprintf "head" "correct certificate: $_ssl_delivered_certificates_file"

    _logger "info" \
      "$_FUNCTION_ID()" \
      "correct certificate: $_ssl_delivered_certificates_file"

    _ssl_delivered_certificates_list+=("$_ssl_delivered_certificates_file")

  else

    _sprintf "stop" "bad certificate (maybe broken): $_ssl_delivered_certificates_file"

    _logger "stop" \
      "$_FUNCTION_ID()" \
      "bad certificate (maybe broken): $_ssl_delivered_certificates_file" && \
      _exit_ 1

  fi

  ssl_delivered_certificates_list+=("${_ssl_delivered_certificates_list[@]}")

  return $_STATE

}

# Extract information about certificates needed to make a proper chain.
function sslInfo() {

  local _FUNCTION_ID="sslInfo"
  local _STATE=0

  local _ssl_ident_issuer_string="Issuer:"
  local _ssl_ident_subject_string="Subject:"
  local _ssl_regexp_string="CN.*=.*"

  local _ssl_delivered_certificates=("${ssl_delivered_certificates_list[@]}")

  local _key_path=""
  local _key_path_name=""
  local _key_issuer=""
  local _key_subject=""

  # Temporary table for storing data in the form path:issuer:subject.
  local _ssl_attr=()

  _logger "info" \
    "$_FUNCTION_ID()" \
    "initialization of variables with initial values"

  for i in "${_ssl_delivered_certificates[@]}" ; do

    _key_path="$i"
    _key_path_name="$(basename "$i")"

    _sprintf "head" "get information from the $_key_path_name" && \
    _logger "info" \
      "$_FUNCTION_ID()" \
      "get information from the $_key_path_name"

    # Responsible for search 'Issuer' and 'Subject' strings defining the relationship between certificates ;
    # removes all whitespace found in strings => (sed 's/  *//g').
    _key_issuer=$(openssl x509 -text -noout -in "$_key_path" | \
          grep "$_ssl_ident_issuer_string" | egrep -o "$_ssl_regexp_string" | \
          cut -d "=" -f2 | \
          sed 's/  *//g')

    _key_subject=$(openssl x509 -text -noout -in "$_key_path" | \
          grep "$_ssl_ident_subject_string" | egrep -o "$_ssl_regexp_string" | \
          cut -d "=" -f2 | \
          sed 's/  *//g' | \
          awk -F '/' '{print $1}')

    _logger "info" \
      "$_FUNCTION_ID()" \
      "adding new elements to the array"

    # Assign an element to the array with 'paht:issuer:subject' notation.
    _ssl_attr+=("${_key_path}:${_key_issuer}:${_key_subject}")

    _sprintf "info" " path: ${_key_path_name}"
    _sprintf "info" " issuer: ${_key_issuer}"
    _sprintf "info" " subject: ${_key_subject}"

    _logger "info" \
      "$_FUNCTION_ID()" \
      "init _ssl_attr=() 'path':'issuer':'subject' notation, _ssl_attr=('${_ssl_attr[-1]}')"

  done

  # Copy the contents of the temporary (local) array to the global array.
  ssl_attr=("${_ssl_attr[@]}")

  _logger "info" \
    "$_FUNCTION_ID()" \
    "copy the contents of local _ssl_attr=() to global ssl_attr=()"

  return $_STATE

}

# It makes a proper chain of delivered certificates.
function sslChain() {

  local _FUNCTION_ID="sslChain"
  local _STATE=0

  # In the initial phase is empty, it will be filled with the sorted items
  # forming the correct string.
  local _ssl_attr_sorted=()

  local _key_path=""
  local _key_issuer=""
  local _key_subject=""

  # local _last_issuer=""
  local _last_subject=""

  _sprintf "head" "creating a chain of delivered certificates"

  # Looking for a server certificate (last certificate of the chain).
  sslChainLast

  # Looking for the relationship between certificates.
  sslChainRelation

  # Generate the correct chain.
  sslChainGenerate

  return $_STATE

}

# Responsible for establishing the Server/Owner Certificate.
function sslChainLast() {

  local _FUNCTION_ID="sslChainLast"
  local _STATE=0

  # Extracting data for each element of the array.
  for i in "${ssl_attr[@]}" ; do

    # for _key_path ; alternative: echo $i | awk -v FS="(:|:)" '{print $1}'
    _key_path="${i%%:*}"
    # for _key_subject ; alternative: echo $i | awk -v FS="(:|:)" '{print $3}'
    _key_subject="${i##*:}"
    # for _key_issuer ;
    _key_issuer=$(echo "$i" | awk -v FS="(:|:)" '{print $2}')

    _logger "info" \
      "$_FUNCTION_ID()" \
      "extracting items from ${i} => 0:${_key_path}, 1:${_key_issuer}, 2:${_key_subject}"

    # If the box contains CN period (e.g. domain.com)
    if [[ "$_key_subject" == *"."* ]] ; then

      # Very important variables that set the beginning of the chain ;
      # it contain 'Server/Owner Certificate' info.
      # _last_issuer="$_key_issuer"
      _last_subject="$_key_subject"

      _logger "info" \
        "$_FUNCTION_ID()" \
        "found server certificate: ${_key_subject}"

      _sprintf "info" " found server certificate: ${_key_subject}"
      # _sprintf "info" " last relationship: ${_key_subject} <==> ${_key_issuer}"

      _logger "info" \
        "$_FUNCTION_ID()" \
        "found last relationship: ${_key_subject} <==> ${_key_issuer}"

    fi

  done

  return $_STATE

}

# Set relationship between certificates.
function sslChainRelation() {

  local _FUNCTION_ID="sslChainRelation"
  local _STATE=0

  local _ssl_attr_num="0"
  local _ssl_keep_num="0"

  while [[ "$_ssl_attr_num" -lt "${#ssl_attr[@]}" ]] ; do

    # Extracting data for each element of the array.
    for i in "${ssl_attr[@]}" ; do

    if [[ "$_ssl_keep_num" -lt "${#ssl_attr[@]}" ]] ; then

      # for _key_path ; alternative: echo $i | awk -v FS="(:|:)" '{print $1}'
      _key_path="${i%%:*}"
      # for _key_subject ; alternative: echo $i | awk -v FS="(:|:)" '{print $3}'
      _key_subject="${i##*:}"
      # for _key_issuer ;
      _key_issuer=$(echo "$i" | awk -v FS="(:|:)" '{print $2}')

      _logger "info" \
        "$_FUNCTION_ID()" \
        "extracting items from ${i} => 0:${_key_path}, 1:${_key_issuer}, 2:${_key_subject}"

      # Compares the current field 'Subject' certificate processed
      # on the last field 'Subject' of the previous certificate.
      if [[ "$_key_subject" == "$_last_subject" ]] ; then

        _sprintf "info" " found relationship: $_key_subject <==> $_key_issuer"

        _sprintf "info" " cert file: $_key_path"

        # Assign an element to the array with 'paht:issuer:subject' notation.
        _ssl_attr_sorted+=("${_key_path}:${_key_issuer}:${_last_subject}")

        _logger "info" \
          "$_FUNCTION_ID()" \
          "found relationship: $_last_subject <==> $_key_issuer"

        _last_subject="$_key_issuer"

        _ssl_keep_num=$((_ssl_keep_num+1))

      fi

    fi

    done

    _ssl_attr_num=$((_ssl_attr_num+1))

  done

  # Copy the sorted contents of the temporary (local) array to the global array.
  ssl_attr_sorted=("${_ssl_attr_sorted[@]}")

  return $_STATE

}

# It generate a proper chain of delivered certificates.
function sslChainGenerate() {

  local _FUNCTION_ID="sslChainGenerate"
  local _STATE=0

  _sprintf "head" "generating $_fd file with the correct chain"

  # The mechanism involved in the location of sorted items.
  for i in "${ssl_attr_sorted[@]}" ; do

    _absolute_path="${i%%:*}"
    _path="$(basename "$_absolute_path")"

    _logger "info" \
      "$_FUNCTION_ID()" \
      "add $_path"

    _sprintf "info" " add: $_path"

    # alternative: (cat "$_absolute_path" ; echo) >> "$_fd"
    cat "$_absolute_path" >> "$_fd"

  done

  return $_STATE

}
